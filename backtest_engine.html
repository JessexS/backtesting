<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Backtest Engine â€” Live Market Simulator</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=IBM+Plex+Sans:wght@300;400;600&display=swap');

:root {
  --bg:        #06080a;
  --s1:        #0c1014;
  --s2:        #111820;
  --border:    #1c2830;
  --border2:   #243040;
  --green:     #26de81;
  --red:       #fc5c65;
  --blue:      #45aaf2;
  --yellow:    #fed330;
  --orange:    #fd9644;
  --purple:    #a55eea;
  --text:      #d8e8f0;
  --muted:     #4a6070;
  --font-mono: 'IBM Plex Mono', monospace;
  --font-sans: 'IBM Plex Sans', sans-serif;
}

* { margin:0; padding:0; box-sizing:border-box; }
html { font-size:13px; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--font-mono);
  height: 100vh;
  overflow: hidden;
}

body::after {
  content:'';
  position:fixed; inset:0;
  background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.025) 2px, rgba(0,0,0,0.025) 4px);
  pointer-events:none; z-index:9999;
}

.shell {
  display: grid;
  grid-template-rows: 52px 1fr;
  grid-template-columns: 248px 1fr 280px;
  height: 100vh;
}

/* TOPBAR */
.topbar {
  grid-column: 1 / -1;
  background: var(--s1);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 18px;
  gap: 14px;
}

.logo {
  font-family: var(--font-sans);
  font-weight: 600;
  font-size: 14px;
  color: #fff;
  display: flex;
  align-items: center;
  gap: 9px;
  flex-shrink: 0;
}

.logo-dot {
  width: 7px; height: 7px;
  background: var(--green);
  border-radius: 50%;
  box-shadow: 0 0 7px var(--green);
  animation: blink 2s ease infinite;
}
.logo-dot.live   { background:var(--red);    box-shadow:0 0 9px var(--red);    animation:blink 0.6s ease infinite; }
.logo-dot.paused { background:var(--yellow); box-shadow:0 0 7px var(--yellow); animation:none; }

@keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.35} }

.vdiv { width:1px; height:20px; background:var(--border); flex-shrink:0; }

.ticker { display:flex; gap:18px; flex:1; overflow:hidden; }
.tick-item { display:flex; align-items:center; gap:7px; font-size:11px; flex-shrink:0; }
.tick-label { color:var(--muted); }
.tick-val   { font-weight:500; transition:color 0.15s; }
.tick-val.fu { color:var(--green); }
.tick-val.fd { color:var(--red);   }

.topbar-right { margin-left:auto; display:flex; gap:7px; align-items:center; flex-shrink:0; }

/* BUTTONS */
.btn {
  font-family:var(--font-mono); font-size:11px;
  padding:5px 13px; border:1px solid; cursor:pointer;
  transition:all 0.18s; letter-spacing:0.5px; white-space:nowrap;
}
.btn-green  { background:var(--green);  border-color:var(--green);  color:#06080a; font-weight:700; }
.btn-green:hover  { box-shadow:0 0 14px rgba(38,222,129,0.5); }
.btn-red    { background:var(--red);    border-color:var(--red);    color:#fff;    font-weight:700; }
.btn-red:hover    { box-shadow:0 0 14px rgba(252,92,101,0.45); }
.btn-yellow { background:var(--yellow); border-color:var(--yellow); color:#06080a; font-weight:700; }
.btn-yellow:hover { box-shadow:0 0 12px rgba(254,211,48,0.4); }
.btn-blue   { background:transparent;  border-color:var(--blue);   color:var(--blue); }
.btn-blue:hover   { background:rgba(69,170,242,0.1); }
.btn-ghost  { background:transparent;  border-color:var(--border2); color:var(--muted); }
.btn-ghost:hover  { border-color:var(--text); color:var(--text); }
.btn:disabled { opacity:0.35; cursor:not-allowed; pointer-events:none; }
.btn-sm { padding:3px 8px; font-size:10px; }
.btn-purple { background:var(--purple); border-color:var(--purple); color:#fff; font-weight:700; }
.btn-purple:hover { box-shadow:0 0 14px rgba(165,94,234,0.5); }
.btn-orange { background:var(--orange); border-color:var(--orange); color:#06080a; font-weight:700; }
.btn-orange:hover { box-shadow:0 0 12px rgba(253,150,68,0.4); }

/* SIDEBAR */
.sidebar {
  background:var(--s1); border-right:1px solid var(--border);
  overflow-y:auto; padding:14px 13px;
  display:flex; flex-direction:column; gap:14px;
}
.sidebar::-webkit-scrollbar { width:3px; }
.sidebar::-webkit-scrollbar-thumb { background:var(--border2); }

/* RIGHT SIDEBAR (Trading Panel) */
.sidebar-right {
  background:var(--s1); border-left:1px solid var(--border);
  overflow-y:auto; padding:14px 13px;
  display:flex; flex-direction:column; gap:14px;
}
.sidebar-right::-webkit-scrollbar { width:3px; }
.sidebar-right::-webkit-scrollbar-thumb { background:var(--border2); }

.panel { background:var(--s2); border:1px solid var(--border); padding:12px; }

.panel-title {
  font-size:9px; letter-spacing:2.5px; text-transform:uppercase;
  color:var(--muted); margin-bottom:12px;
  display:flex; align-items:center; gap:8px;
}
.panel-title::after { content:''; flex:1; height:1px; background:var(--border); }

.control { margin-bottom:10px; }
.control:last-child { margin-bottom:0; }
.control label { display:flex; justify-content:space-between; font-size:11px; color:var(--muted); margin-bottom:5px; }
.control label span { color:var(--blue); font-weight:500; }

input[type=range] {
  width:100%; -webkit-appearance:none; height:2px;
  background:var(--border2); outline:none; cursor:pointer;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:11px; height:11px;
  border-radius:50%; background:var(--blue); box-shadow:0 0 5px var(--blue); cursor:pointer;
}

input[type=number], select, textarea {
  width:100%; background:var(--bg); border:1px solid var(--border);
  color:var(--text); font-family:var(--font-mono); font-size:11px;
  padding:5px 8px; outline:none;
}
input[type=number]:focus, select:focus, textarea:focus { border-color:var(--blue); }
select { cursor:pointer; }
textarea { resize:vertical; min-height:60px; }

.speed-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:4px; margin-top:8px; }
.speed-btn {
  font-family:var(--font-mono); font-size:11px; padding:4px 0;
  background:var(--bg); border:1px solid var(--border); color:var(--muted);
  cursor:pointer; text-align:center; transition:all 0.15s;
}
.speed-btn.active { border-color:var(--blue); color:var(--blue); background:rgba(69,170,242,0.1); }

.live-counter {
  background:var(--bg); border:1px solid var(--border);
  padding:9px 12px; display:flex; justify-content:space-between; align-items:center;
  margin-bottom:12px;
}
.lc-label { font-size:9px; color:var(--muted); letter-spacing:1.5px; text-transform:uppercase; }
.lc-val   { font-size:22px; font-weight:600; color:var(--green); font-variant-numeric:tabular-nums; }
@keyframes cpulse { 0%{transform:scale(1)} 50%{transform:scale(1.1)} 100%{transform:scale(1)} }
.lc-val.pulse { animation:cpulse 0.25s ease; }

.regime-list { display:flex; flex-direction:column; gap:5px; }
.regime-item {
  display:flex; align-items:center; gap:7px; padding:5px 8px;
  border:1px solid var(--border); font-size:11px; opacity:0.35; transition:all 0.2s;
}
.regime-item.active { opacity:1; background:var(--bg); }
.regime-dot  { width:6px; height:6px; border-radius:50%; flex-shrink:0; }
.regime-name { flex:1; }
.regime-pct  { color:var(--muted); font-size:10px; }

.stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
.stat { background:var(--bg); border:1px solid var(--border); padding:9px; }
.stat-label { font-size:9px; color:var(--muted); letter-spacing:1.5px; text-transform:uppercase; margin-bottom:3px; }
.stat-value { font-size:14px; font-weight:600; line-height:1; }
.stat-value.sm { font-size:11px; }
.up   { color:var(--green); }
.down { color:var(--red);   }
.neu  { color:var(--blue);  }

/* MAIN */
.main { display:flex; flex-direction:column; overflow:hidden; }

.chart-toolbar {
  background:var(--s1); border-bottom:1px solid var(--border);
  padding:8px 18px; display:flex; align-items:center; gap:10px;
}
.pair-badge { font-family:var(--font-sans); font-size:15px; font-weight:600; color:#fff; }

.live-badge {
  font-size:9px; letter-spacing:2px; padding:2px 8px;
  font-weight:700; display:none; border-radius:1px;
}
.live-badge.show { display:inline-block; }
.live-badge.live   { background:rgba(252,92,101,0.18); border:1px solid var(--red);    color:var(--red);    animation:blink 0.8s ease infinite; }
.live-badge.paused { background:rgba(254,211,48,0.15);  border:1px solid var(--yellow); color:var(--yellow); animation:none; }

.chart-area { flex:1; position:relative; min-height:0; }
#cc { display:block; position:absolute; inset:0; width:100%!important; height:100%!important; }

.tooltip-box {
  position:absolute; background:var(--s1); border:1px solid var(--border2);
  padding:9px 13px; font-size:11px; pointer-events:none; z-index:100; display:none; min-width:150px;
}
.tooltip-box.vis { display:block; }
.tt-row { display:flex; justify-content:space-between; gap:14px; margin-bottom:3px; }
.tt-row:last-child { margin:0; }
.tt-key { color:var(--muted); }
.tt-val { font-weight:500; }

.timeline-area { padding:8px 18px 9px; border-top:1px solid var(--border); background:var(--s1); }
.tl-label { font-size:9px; color:var(--muted); letter-spacing:1.5px; text-transform:uppercase; margin-bottom:5px; }
.timeline-bar { height:10px; display:flex; gap:1px; overflow:hidden; border-radius:2px; }
.tl-seg { height:100%; transition:opacity 0.15s; cursor:default; }
.tl-seg:hover { opacity:0.7; }

/* Equity chart area */
.equity-area {
  height:100px; position:relative; border-top:1px solid var(--border); background:var(--s1);
  flex-shrink:0;
}
#eqc { display:block; position:absolute; inset:0; width:100%!important; height:100%!important; }

.export-bar {
  border-top:1px solid var(--border); background:var(--s1);
  padding:9px 18px; display:flex; align-items:center; gap:10px; font-size:11px;
}
.export-info { color:var(--muted); flex:1; }
.export-info strong { color:var(--text); }

.nc-flash {
  position:absolute; right:0; top:0; bottom:0; width:2px;
  background:var(--green); opacity:0; pointer-events:none;
}
@keyframes ncf { 0%{opacity:0.8} 100%{opacity:0} }
.nc-flash.f { animation:ncf 0.3s ease forwards; }

/* Trade buttons row */
.trade-btns { display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-top:8px; }

/* Toggle switch */
.toggle-row { display:flex; align-items:center; justify-content:space-between; font-size:11px; color:var(--muted); }
.toggle { position:relative; width:34px; height:18px; cursor:pointer; }
.toggle input { display:none; }
.toggle-slider {
  position:absolute; inset:0; background:var(--border2); border-radius:9px; transition:0.2s;
}
.toggle-slider::before {
  content:''; position:absolute; left:2px; top:2px; width:14px; height:14px;
  background:var(--muted); border-radius:50%; transition:0.2s;
}
.toggle input:checked + .toggle-slider { background:var(--green); }
.toggle input:checked + .toggle-slider::before { transform:translateX(16px); background:#fff; }

/* Trade log */
.trade-log { max-height:180px; overflow-y:auto; font-size:10px; }
.trade-log::-webkit-scrollbar { width:2px; }
.trade-log::-webkit-scrollbar-thumb { background:var(--border2); }
.trade-log-item {
  display:flex; gap:6px; padding:4px 6px; border-bottom:1px solid var(--border);
  align-items:center;
}
.trade-log-item .dir { font-weight:700; font-size:9px; padding:1px 4px; }
.trade-log-item .dir.long { background:rgba(38,222,129,0.15); color:var(--green); }
.trade-log-item .dir.short { background:rgba(252,92,101,0.15); color:var(--red); }
.trade-log-item .pnl { margin-left:auto; font-weight:600; }

/* Strategy error */
.strat-error {
  background:rgba(252,92,101,0.1); border:1px solid var(--red);
  color:var(--red); font-size:10px; padding:6px 8px; margin-top:6px;
  max-height:60px; overflow-y:auto; display:none; word-break:break-all;
}
.strat-error.show { display:block; }

/* MC results */
.mc-results { font-size:10px; max-height:200px; overflow-y:auto; }
.mc-results::-webkit-scrollbar { width:2px; }
.mc-results::-webkit-scrollbar-thumb { background:var(--border2); }
.mc-table { width:100%; border-collapse:collapse; font-size:10px; }
.mc-table th { text-align:left; color:var(--muted); padding:3px 4px; border-bottom:1px solid var(--border); font-weight:400; font-size:9px; letter-spacing:1px; text-transform:uppercase; }
.mc-table td { padding:3px 4px; border-bottom:1px solid var(--border); }

/* MODAL */
.modal-overlay {
  position:fixed; inset:0; background:rgba(6,8,10,0.88);
  z-index:1000; display:none; align-items:center; justify-content:center;
  backdrop-filter:blur(4px);
}
.modal-overlay.show { display:flex; }
.modal {
  background:var(--s1); border:1px solid var(--border2);
  padding:30px; width:440px; max-width:92vw;
  animation:min 0.18s ease;
}
@keyframes min { from{opacity:0;transform:translateY(-14px) scale(0.97)} to{opacity:1;transform:none} }
.modal-title { font-family:var(--font-sans); font-size:17px; font-weight:600; color:#fff; margin-bottom:5px; }
.modal-sub   { font-size:11px; color:var(--muted); margin-bottom:22px; }

.export-opts { display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:20px; }
.exp-opt {
  border:1px solid var(--border2); background:var(--s2);
  padding:18px 14px; cursor:pointer; transition:all 0.18s; text-align:center;
}
.exp-opt:hover   { border-color:var(--blue); background:rgba(69,170,242,0.06); }
.exp-opt.sel     { border-color:var(--green); background:rgba(38,222,129,0.06); }
.exp-icon  { font-size:26px; margin-bottom:9px; }
.exp-title { font-size:13px; font-weight:600; color:#fff; margin-bottom:4px; }
.exp-desc  { font-size:10px; color:var(--muted); line-height:1.5; }

.modal-footer { display:flex; gap:8px; justify-content:flex-end; }

/* Input group row */
.input-row { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
.input-group { margin-bottom:8px; }
.input-group label { display:block; font-size:10px; color:var(--muted); margin-bottom:3px; letter-spacing:0.5px; }

/* Collapsible panel */
.panel-collapse { cursor:pointer; user-select:none; }
.panel-collapse .panel-title::before { content:'â–¸'; margin-right:4px; transition:transform 0.2s; display:inline-block; }
.panel-collapse.open .panel-title::before { transform:rotate(90deg); }
.panel-body { display:none; }
.panel-collapse.open .panel-body { display:block; }

/* Position list */
.pos-list { font-size:10px; }
.pos-item {
  background:var(--bg); border:1px solid var(--border); padding:6px 8px; margin-bottom:4px;
}
.pos-item .pos-head { display:flex; justify-content:space-between; align-items:center; margin-bottom:3px; }
.pos-item .pos-detail { display:flex; gap:8px; color:var(--muted); font-size:9px; flex-wrap:wrap; }
.pos-close-btn { font-size:9px; padding:1px 6px; cursor:pointer; background:var(--red); border:1px solid var(--red); color:#fff; }
</style>
</head>
<body>
<div class="shell">

  <!-- TOPBAR -->
  <header class="topbar">
    <div class="logo">
      <div class="logo-dot" id="dot"></div>
      BACKTEST ENGINE
      <span style="color:var(--muted);font-weight:300;font-size:11px">// Live Simulator</span>
    </div>
    <div class="vdiv"></div>
    <div class="ticker">
      <div class="tick-item"><span class="tick-label">PRICE</span>  <span class="tick-val" id="tkP">â€”</span></div>
      <div class="tick-item"><span class="tick-label">CHG</span>    <span class="tick-val" id="tkC">â€”</span></div>
      <div class="tick-item"><span class="tick-label">HIGH</span>   <span class="tick-val" id="tkH">â€”</span></div>
      <div class="tick-item"><span class="tick-label">LOW</span>    <span class="tick-val" id="tkL">â€”</span></div>
      <div class="tick-item"><span class="tick-label">VOL</span>    <span class="tick-val" id="tkV">â€”</span></div>
      <div class="tick-item"><span class="tick-label">REGIME</span> <span class="tick-val" id="tkR">â€”</span></div>
      <div class="tick-item"><span class="tick-label">EQUITY</span> <span class="tick-val" id="tkEq">â€”</span></div>
    </div>
    <div class="topbar-right">
      <button class="btn btn-green"  id="btnStart" onclick="startLive()">â–¶ START</button>
      <button class="btn btn-yellow" id="btnPause" onclick="pauseLive()" disabled>â¸ PAUSE</button>
      <button class="btn btn-red"    id="btnStop"  onclick="stopLive()"  disabled>â–  STOP</button>
      <div class="vdiv"></div>
      <button class="btn btn-ghost"  onclick="resetAll()">âŸ³ RESET</button>
    </div>
  </header>

  <!-- LEFT SIDEBAR -->
  <aside class="sidebar">
    <div class="panel">
      <div class="panel-title">Live Session</div>
      <div class="live-counter">
        <span class="lc-label">KynttilÃ¤t tallennettu</span>
        <span class="lc-val" id="liveCount">0</span>
      </div>
      <div class="panel-title" style="margin-bottom:6px">Nopeus</div>
      <div class="speed-grid">
        <div class="speed-btn" data-ms="2000" onclick="setSpeed(2000)">0.5Ã—</div>
        <div class="speed-btn active" data-ms="800" onclick="setSpeed(800)">1Ã—</div>
        <div class="speed-btn" data-ms="250" onclick="setSpeed(250)">3Ã—</div>
        <div class="speed-btn" data-ms="60"  onclick="setSpeed(60)">15Ã—</div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-title">Parametrit</div>
      <div class="control">
        <label>Aloitushinta <span id="lbS">10 000</span></label>
        <input type="range" id="rS" min="100" max="100000" step="100" value="10000"
          oninput="document.getElementById('lbS').textContent=(+this.value).toLocaleString('fi')">
      </div>
      <div class="control">
        <label>Volatiliteetti <span id="lbV">1.5%</span></label>
        <input type="range" id="rV" min="0.3" max="5" step="0.1" value="1.5"
          oninput="document.getElementById('lbV').textContent=this.value+'%'">
      </div>
      <div class="control">
        <label>Trendi-bias <span id="lbB">0.00%</span></label>
        <input type="range" id="rB" min="-0.5" max="0.5" step="0.01" value="0"
          oninput="document.getElementById('lbB').textContent=(+this.value>=0?'+':'')+this.value+'%'">
      </div>
      <div class="control">
        <label>Regiimin vaihtuvuus <span id="lbSw">8%</span></label>
        <input type="range" id="rSw" min="1" max="30" step="1" value="8"
          oninput="document.getElementById('lbSw').textContent=this.value+'%'">
      </div>
      <div class="control">
        <label>Seed <span id="lbSd">42</span></label>
        <input type="range" id="rSd" min="1" max="999" step="1" value="42"
          oninput="document.getElementById('lbSd').textContent=this.value">
      </div>
    </div>

    <div class="panel">
      <div class="panel-title">Regiiimit</div>
      <div class="regime-list">
        <div class="regime-item" id="ri-bull">     <div class="regime-dot" style="background:#26de81"></div><span class="regime-name">Bull Trend</span>  <span class="regime-pct" id="pct-bull">â€”</span></div>
        <div class="regime-item" id="ri-bear">     <div class="regime-dot" style="background:#fc5c65"></div><span class="regime-name">Bear Trend</span>  <span class="regime-pct" id="pct-bear">â€”</span></div>
        <div class="regime-item" id="ri-sideways"> <div class="regime-dot" style="background:#45aaf2"></div><span class="regime-name">Sideways</span>     <span class="regime-pct" id="pct-sideways">â€”</span></div>
        <div class="regime-item" id="ri-swing">    <div class="regime-dot" style="background:#fed330"></div><span class="regime-name">Swing</span>        <span class="regime-pct" id="pct-swing">â€”</span></div>
        <div class="regime-item" id="ri-breakout"> <div class="regime-dot" style="background:#fd9644"></div><span class="regime-name">Breakout</span>     <span class="regime-pct" id="pct-breakout">â€”</span></div>
        <div class="regime-item" id="ri-crash">    <div class="regime-dot" style="background:#a55eea"></div><span class="regime-name">Flash Crash</span> <span class="regime-pct" id="pct-crash">â€”</span></div>
      </div>
    </div>

    <div class="panel">
      <div class="panel-title">Statistiikka</div>
      <div class="stats-grid">
        <div class="stat"><div class="stat-label">Aloitus</div>     <div class="stat-value neu"  id="stS">â€”</div></div>
        <div class="stat"><div class="stat-label">Nykyinen</div>    <div class="stat-value"       id="stN">â€”</div></div>
        <div class="stat"><div class="stat-label">High</div>        <div class="stat-value up"    id="stH">â€”</div></div>
        <div class="stat"><div class="stat-label">Low</div>         <div class="stat-value down"  id="stL">â€”</div></div>
        <div class="stat"><div class="stat-label">Max Drawdown</div><div class="stat-value down"  id="stDD">â€”</div></div>
        <div class="stat"><div class="stat-label">Tuotto</div>      <div class="stat-value"       id="stRt">â€”</div></div>
      </div>
    </div>
  </aside>

  <!-- MAIN -->
  <main class="main">
    <div class="chart-toolbar">
      <span class="pair-badge">BTC/USDT</span>
      <span class="live-badge" id="liveBadge">LIVE</span>
      <span style="margin-left:auto;font-size:10px;color:var(--muted)">Scroll = pan Â· Ctrl+Scroll = zoom Â· Drag = pan</span>
    </div>

    <div class="chart-area">
      <canvas id="cc"></canvas>
      <div class="nc-flash" id="ncf"></div>
      <div class="tooltip-box" id="tooltip">
        <div class="tt-row"><span class="tt-key">Aika</span>   <span class="tt-val" id="tta">â€”</span></div>
        <div class="tt-row"><span class="tt-key">Open</span>   <span class="tt-val" id="tto">â€”</span></div>
        <div class="tt-row"><span class="tt-key">High</span>   <span class="tt-val" id="tth">â€”</span></div>
        <div class="tt-row"><span class="tt-key">Low</span>    <span class="tt-val" id="ttl">â€”</span></div>
        <div class="tt-row"><span class="tt-key">Close</span>  <span class="tt-val" id="ttc">â€”</span></div>
        <div class="tt-row"><span class="tt-key">Volume</span> <span class="tt-val" id="ttv">â€”</span></div>
        <div class="tt-row"><span class="tt-key">Regime</span> <span class="tt-val" id="ttr">â€”</span></div>
      </div>
    </div>

    <div class="equity-area" id="eqArea" style="display:none">
      <canvas id="eqc"></canvas>
    </div>

    <div class="timeline-area">
      <div class="tl-label">Regiimi-aikajana</div>
      <div class="timeline-bar" id="tlBar"></div>
    </div>

    <div class="export-bar">
      <span class="export-info" id="expInfo">Paina <strong>â–¶ START</strong> aloittaaksesi live-datan tallennuksen.</span>
      <button class="btn btn-blue btn-sm" id="btnExportTrades" onclick="exportTradeCSV()" disabled>â†“ TRADES CSV</button>
      <button class="btn btn-blue" id="btnExport" onclick="openModal()" disabled>â†“ EXPORTOI DATA</button>
    </div>
  </main>

  <!-- RIGHT SIDEBAR: Trading Panel -->
  <aside class="sidebar-right" id="tradingPanel">
    <!-- Mode & Settings -->
    <div class="panel">
      <div class="panel-title">Trading Mode</div>
      <div class="input-row">
        <div class="input-group">
          <label>Mode</label>
          <select id="tMode" onchange="onTradingModeChange()">
            <option value="spot">Spot</option>
            <option value="futures" selected>Futures (Isolated)</option>
          </select>
        </div>
        <div class="input-group">
          <label>Leverage</label>
          <select id="tLev">
            <option value="1">1Ã—</option><option value="2">2Ã—</option><option value="3">3Ã—</option>
            <option value="5">5Ã—</option><option value="10" selected>10Ã—</option><option value="20">20Ã—</option>
            <option value="25">25Ã—</option><option value="40">40Ã—</option>
          </select>
        </div>
      </div>
      <div class="input-row">
        <div class="input-group">
          <label>Maker Fee %</label>
          <input type="number" id="tMakerFee" value="0.02" step="0.001" min="0">
        </div>
        <div class="input-group">
          <label>Taker Fee %</label>
          <input type="number" id="tTakerFee" value="0.04" step="0.001" min="0">
        </div>
      </div>
      <div class="input-row">
        <div class="input-group">
          <label>Slippage %</label>
          <input type="number" id="tSlippage" value="0.05" step="0.01" min="0">
        </div>
        <div class="input-group">
          <label>Maint. Rate %</label>
          <input type="number" id="tMaintRate" value="0.5" step="0.1" min="0">
        </div>
      </div>
      <div class="input-row">
        <div class="input-group">
          <label>Starting Balance</label>
          <input type="number" id="tBalance" value="10000" step="100" min="100">
        </div>
        <div class="input-group">
          <label>Position Sizing</label>
          <select id="tSizeMode">
            <option value="fixed">Fixed Amount</option>
            <option value="percent">% of Equity</option>
          </select>
        </div>
      </div>
      <div class="input-group">
        <label>Size Value</label>
        <input type="number" id="tSizeVal" value="1000" step="100" min="1">
      </div>
      <div class="input-row" style="margin-top:4px">
        <div class="input-group">
          <label>Stop Loss %</label>
          <input type="number" id="tSL" value="2" step="0.1" min="0">
        </div>
        <div class="input-group">
          <label>Take Profit %</label>
          <input type="number" id="tTP" value="4" step="0.1" min="0">
        </div>
      </div>
      <div class="input-group">
        <label>Trailing Stop %</label>
        <input type="number" id="tTrail" value="0" step="0.1" min="0">
      </div>
      <div class="input-group">
        <label>Partial Fill %</label>
        <input type="number" id="tPartialFill" value="100" step="5" min="5" max="100">
      </div>
      <div class="trade-btns">
        <button class="btn btn-green btn-sm" onclick="manualBuy()">â–² BUY/LONG</button>
        <button class="btn btn-red btn-sm" onclick="manualSell()">â–¼ SELL/SHORT</button>
      </div>
    </div>

    <!-- Strategy -->
    <div class="panel panel-collapse open" onclick="this.classList.toggle('open')">
      <div class="panel-title">Strategy Engine</div>
      <div class="panel-body" onclick="event.stopPropagation()">
        <div class="toggle-row" style="margin-bottom:8px">
          <span>Enable Strategy</span>
          <label class="toggle"><input type="checkbox" id="tStratEnabled"><span class="toggle-slider"></span></label>
        </div>
        <div class="input-group">
          <label>Strategy Code (JS)</label>
          <textarea id="tStratCode" rows="8" placeholder="// Strategy lifecycle:
// init(ctx), onCandle(ctx),
// onOrderFilled(ctx), onLiquidation(ctx),
// onFinish(ctx)
//
// ctx: {candle, candles, positions,
//   equity, balance, fees, orders,
//   utils: {Math}}
//
// Return orders from onCandle:
// return [{side:'buy', size:100}]"></textarea>
        </div>
        <div style="display:flex;gap:6px">
          <button class="btn btn-blue btn-sm" onclick="loadStrategy()">Load Strategy</button>
          <button class="btn btn-ghost btn-sm" onclick="loadBundledStrategy()">Load ARM v2</button>
          <label class="btn btn-ghost btn-sm" style="display:inline-flex;align-items:center;cursor:pointer">
            Upload File <input type="file" accept=".js,.txt" style="display:none" onchange="uploadStrategy(event)">
          </label>
        </div>
        <div class="strat-error" id="stratError"></div>
      </div>
    </div>

    <!-- Positions -->
    <div class="panel panel-collapse open" onclick="this.classList.toggle('open')">
      <div class="panel-title">Open Positions <span id="posCount" style="color:var(--blue)">(0)</span></div>
      <div class="panel-body" onclick="event.stopPropagation()">
        <div class="pos-list" id="posList"></div>
      </div>
    </div>

    <!-- Performance Metrics -->
    <div class="panel panel-collapse open" onclick="this.classList.toggle('open')">
      <div class="panel-title">Performance</div>
      <div class="panel-body" onclick="event.stopPropagation()">
        <div class="stats-grid" id="perfGrid">
          <div class="stat"><div class="stat-label">Balance</div><div class="stat-value sm neu" id="pmBal">â€”</div></div>
          <div class="stat"><div class="stat-label">Equity</div><div class="stat-value sm neu" id="pmEq">â€”</div></div>
          <div class="stat"><div class="stat-label">Unreal. PnL</div><div class="stat-value sm" id="pmUPnl">â€”</div></div>
          <div class="stat"><div class="stat-label">Real. PnL</div><div class="stat-value sm" id="pmRPnl">â€”</div></div>
          <div class="stat"><div class="stat-label">Win Rate</div><div class="stat-value sm" id="pmWR">â€”</div></div>
          <div class="stat"><div class="stat-label">Profit Factor</div><div class="stat-value sm" id="pmPF">â€”</div></div>
          <div class="stat"><div class="stat-label">Sharpe</div><div class="stat-value sm" id="pmSh">â€”</div></div>
          <div class="stat"><div class="stat-label">Max DD</div><div class="stat-value sm down" id="pmDD">â€”</div></div>
          <div class="stat"><div class="stat-label">Expectancy</div><div class="stat-value sm" id="pmExp">â€”</div></div>
          <div class="stat"><div class="stat-label">Kelly %</div><div class="stat-value sm" id="pmKe">â€”</div></div>
          <div class="stat"><div class="stat-label">Avg R</div><div class="stat-value sm" id="pmAvgR">â€”</div></div>
          <div class="stat"><div class="stat-label">Max Consec Loss</div><div class="stat-value sm down" id="pmMCL">â€”</div></div>
          <div class="stat"><div class="stat-label">Exposure %</div><div class="stat-value sm" id="pmExpo">â€”</div></div>
          <div class="stat"><div class="stat-label">Total Fees</div><div class="stat-value sm down" id="pmFees">â€”</div></div>
        </div>
      </div>
    </div>

    <!-- Trade Log -->
    <div class="panel panel-collapse" onclick="this.classList.toggle('open')">
      <div class="panel-title">Trade Log <span id="tradeCount" style="color:var(--blue)">(0)</span></div>
      <div class="panel-body" onclick="event.stopPropagation()">
        <div class="trade-log" id="tradeLog"></div>
      </div>
    </div>

    <!-- Monte Carlo -->
    <div class="panel panel-collapse" onclick="this.classList.toggle('open')">
      <div class="panel-title">Monte Carlo</div>
      <div class="panel-body" onclick="event.stopPropagation()">
        <div class="input-row">
          <div class="input-group">
            <label>Runs</label>
            <input type="number" id="mcRuns" value="50" step="10" min="5" max="500">
          </div>
          <div class="input-group">
            <label>Candles/Run</label>
            <input type="number" id="mcCandles" value="500" step="50" min="50" max="5000">
          </div>
        </div>
        <div class="toggle-row" style="margin-bottom:8px;margin-top:4px">
          <span>Overlay Equity Curves</span>
          <label class="toggle"><input type="checkbox" id="mcOverlay"><span class="toggle-slider"></span></label>
        </div>
        <button class="btn btn-purple btn-sm" onclick="runMonteCarlo()" id="btnMC" style="width:100%;margin-bottom:8px">â–¶ RUN MONTE CARLO</button>
        <div class="mc-results" id="mcResults"></div>
      </div>
    </div>
  </aside>
</div>

<!-- EXPORT MODAL -->
<div class="modal-overlay" id="modal" onclick="if(event.target===this)closeModal()">
  <div class="modal">
    <div class="modal-title">Exportoi markkinadata</div>
    <div class="modal-sub" id="modalSub">â€”</div>
    <div class="export-opts">
      <div class="exp-opt sel" id="optXlsx" onclick="selFmt('xlsx')">
        <div class="exp-icon">ğŸ“Š</div>
        <div class="exp-title">Excel (.xlsx)</div>
        <div class="exp-desc">OHLCV-data + regiimitilastot kahdella vÃ¤lilehdellÃ¤. Sopii analyysiin.</div>
      </div>
      <div class="exp-opt" id="optJson" onclick="selFmt('json')">
        <div class="exp-icon">{ }</div>
        <div class="exp-title">JSON</div>
        <div class="exp-desc">TÃ¤ydellinen raakadata ohjelmalliseen kÃ¤yttÃ¶Ã¶n ja backtest-pipelineen.</div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn btn-ghost" onclick="closeModal()">Peruuta</button>
      <button class="btn btn-green" onclick="doExport()">â†“ Lataa tiedosto</button>
    </div>
  </div>
</div>

<!-- Bundled strategy (loads local file when available) -->
<script src="./arm_strategy_v2.js"></script>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: RNG â€” Mulberry32 (seeded, reproducible)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function mkRNG(seed) {
  let s = (seed * 1234567 + 1) >>> 0;
  return {
    r() {
      s |= 0; s = s + 0x6D2B79F5 | 0;
      let t = Math.imul(s ^ s >>> 15, 1 | s);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    },
    n(mu=0, sig=1) {
      const u = 1-this.r(), v = this.r();
      return mu + sig * Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
    },
    e(lam=1) { return -Math.log(1-this.r())/lam; }
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: REGIMES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const RK = ['bull','bear','sideways','swing','breakout','crash'];
const RG = {
  bull:     {color:'#26de81',name:'Bull Trend',   drift: 0.003, vM:0.8, wM:1.0, vB:1.2, gP:0.03, gD: 1},
  bear:     {color:'#fc5c65',name:'Bear Trend',   drift:-0.003, vM:1.1, wM:1.3, vB:1.4, gP:0.04, gD:-1},
  sideways: {color:'#45aaf2',name:'Sideways',     drift: 0.0,  vM:0.5, wM:0.8, vB:0.6, gP:0.01, gD: 0, mr:0.15},
  swing:    {color:'#fed330',name:'Swing',        drift: 0.0,  vM:1.3, wM:1.5, vB:1.1, gP:0.05, gD: 0, sc:20},
  breakout: {color:'#fd9644',name:'Breakout',     drift: 0.006,vM:2.5, wM:0.5, vB:3.0, gP:0.12, gD: 1, dur:[10,30]},
  crash:    {color:'#a55eea',name:'Flash Crash',  drift:-0.015,vM:4.0, wM:2.0, vB:5.0, gP:0.20, gD:-1, dur:[5,20]},
};
const TR = {
  bull:     [0.65,0.05,0.15,0.08,0.06,0.01],
  bear:     [0.05,0.60,0.15,0.10,0.02,0.08],
  sideways: [0.15,0.10,0.45,0.20,0.08,0.02],
  swing:    [0.12,0.12,0.20,0.42,0.10,0.04],
  breakout: [0.35,0.15,0.20,0.15,0.10,0.05],
  crash:    [0.10,0.40,0.20,0.15,0.05,0.10],
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: MarketEngine â€” wraps Gen, generates candles
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Gen {
  constructor(p) {
    this.rng = mkRNG(p.seed);
    this.price = p.sp;
    this.bvol  = p.bv;
    this.bias  = p.bias;
    this.swP   = p.sw / 100;
    this.bVol  = p.sp * 12;
    this.regime = 'bull';
    this.age = 0; this.sp = 0; this.anchor = p.sp;
    this.counts = {}; RK.forEach(k => this.counts[k]=0);
    this.idx = 0;
  }
  next() {
    const rng = this.rng;
    const R = RG[this.regime];
    this.counts[this.regime]++;
    this.age++;
    let sw = rng.r() < this.swP;
    if (R.dur) { const [a,b]=R.dur; if (this.age>a&&(sw||this.age>b)) sw=true; }
    if (sw && this.idx>0) {
      const pr = TR[this.regime]; let rv=rng.r(), cm=0;
      for (let j=0;j<RK.length;j++){cm+=pr[j]; if(rv<cm){this.regime=RK[j];break;}}
      this.age=0; this.anchor=this.price;
    }
    const Rr = RG[this.regime];
    let drift = Rr.drift + this.bias;
    const vol = this.bvol * Rr.vM;
    if (this.regime==='swing') { this.sp += (2*Math.PI)/(Rr.sc||20); drift+=Math.sin(this.sp)*0.008; }
    if (this.regime==='sideways'&&Rr.mr) drift -= ((this.price-this.anchor)/this.anchor)*Rr.mr;
    let gF=1;
    if (rng.r()<Rr.gP) { const gs=rng.e(20)*0.01; const gd=Rr.gD||((rng.r()>0.5)?1:-1); gF=1+gd*gs; }
    const open  = this.price*gF;
    const ret   = rng.n(drift,vol);
    const close = open*(1+ret);
    const hw    = Math.abs(rng.n(0,vol*Rr.wM*0.5));
    const lw    = Math.abs(rng.n(0,vol*Rr.wM*0.5));
    const high  = Math.max(open,close)*(1+hw);
    const low   = Math.min(open,close)*(1-lw);
    const vol2  = Math.max(0, this.bVol*Rr.vB*Math.abs(ret/this.bvol)*5*rng.n(1,0.3));
    this.price = close;
    this.idx++;
    return {i:this.idx, time:new Date().toISOString(),
      open:+open.toFixed(2), high:+high.toFixed(2),
      low:+low.toFixed(2), close:+close.toFixed(2),
      volume:+vol2.toFixed(0), regime:this.regime};
  }
}

class MarketEngine {
  constructor() { this.gen = null; this.candles = []; }
  init(params) {
    this.gen = new Gen(params);
    this.candles = [];
  }
  nextCandle() {
    const c = this.gen.next();
    this.candles.push(c);
    return c;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: TradingEngine â€” positions, orders, margin
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class TradingEngine {
  constructor() { this.reset(); }
  reset() {
    this.mode = 'futures';
    this.leverage = 10;
    this.makerFee = 0.0002;
    this.takerFee = 0.0004;
    this.slippage = 0.0005;
    this.maintRate = 0.005;
    this.partialFillPct = 1.0;
    this.balance = 10000;
    this.initialBalance = 10000;
    this.positions = [];
    this.closedTrades = [];
    this.pendingOrders = [];
    this.totalFees = 0;
    this.tradeIdCounter = 0;
    this.orderIdCounter = 0;
    this.equityCurve = [];
    this.balanceCurve = [];
    this.exposedCandles = 0;
    this.totalCandles = 0;
  }

  loadSettings() {
    this.mode = document.getElementById('tMode').value;
    this.leverage = +document.getElementById('tLev').value;
    this.makerFee = +document.getElementById('tMakerFee').value / 100;
    this.takerFee = +document.getElementById('tTakerFee').value / 100;
    this.slippage = +document.getElementById('tSlippage').value / 100;
    this.maintRate = +document.getElementById('tMaintRate').value / 100;
    this.partialFillPct = +document.getElementById('tPartialFill').value / 100;
    this.initialBalance = +document.getElementById('tBalance').value;
    this.balance = this.initialBalance;
  }

  getOrderSize(price) {
    const mode = document.getElementById('tSizeMode').value;
    const val = +document.getElementById('tSizeVal').value;
    const equity = this.getEquity(price);
    if (mode === 'percent') return (equity * val / 100) / price;
    return val / price;
  }

  getEquity(price) {
    let unrealized = 0;
    for (const pos of this.positions) {
      unrealized += this._calcPnL(pos, price);
    }
    return this.balance + unrealized;
  }

  getUnrealizedPnL(price) {
    let u = 0;
    for (const pos of this.positions) u += this._calcPnL(pos, price);
    return u;
  }

  _calcPnL(pos, price) {
    const diff = pos.direction === 'long' ? (price - pos.entryPrice) : (pos.entryPrice - price);
    return diff * pos.size;
  }

  _calcLiquidationPrice(pos) {
    if (this.mode === 'spot') return 0;
    const margin = pos.margin;
    const maint = pos.size * pos.entryPrice * this.maintRate;
    if (pos.direction === 'long') {
      return pos.entryPrice - (margin - maint) / pos.size;
    } else {
      return pos.entryPrice + (margin - maint) / pos.size;
    }
  }

  createOrder(type, side, price, size, opts = {}) {
    const id = ++this.orderIdCounter;
    const order = {
      id, type, side, price, size,
      stopLoss: opts.stopLoss || 0,
      takeProfit: opts.takeProfit || 0,
      trailingStop: opts.trailingStop || 0,
      status: 'pending',
      createdAt: opts.time || new Date().toISOString(),
      filledAt: null,
      filledPrice: null
    };
    this.pendingOrders.push(order);
    return order;
  }

  // Check and process liquidations
  checkLiquidations(candle) {
    const liquidated = [];
    for (let i = this.positions.length - 1; i >= 0; i--) {
      const pos = this.positions[i];
      if (this.mode === 'spot') continue;
      const liqPrice = pos.liquidationPrice;
      let hit = false;
      if (pos.direction === 'long' && candle.low <= liqPrice) hit = true;
      if (pos.direction === 'short' && candle.high >= liqPrice) hit = true;
      if (hit) {
        const trade = this._closeTrade(pos, liqPrice, candle.time, 'liquidation');
        trade.pnl = -pos.margin; // lose entire margin
        this.balance -= pos.margin; // was already deducted conceptually
        // Re-add margin then subtract loss
        this.balance += pos.margin + trade.pnl;
        liquidated.push(trade);
        this.positions.splice(i, 1);
      }
    }
    return liquidated;
  }

  // Check SL/TP/Trailing for all positions
  checkStopsTakeProfits(candle) {
    const closed = [];
    for (let i = this.positions.length - 1; i >= 0; i--) {
      const pos = this.positions[i];
      let closePrice = null;
      let reason = null;

      // Update trailing stop
      if (pos.trailingStop > 0) {
        if (pos.direction === 'long') {
          const newTrailPrice = candle.high * (1 - pos.trailingStop / 100);
          if (!pos._trailPrice || newTrailPrice > pos._trailPrice) pos._trailPrice = newTrailPrice;
          if (candle.low <= pos._trailPrice) { closePrice = pos._trailPrice; reason = 'trailing_stop'; }
        } else {
          const newTrailPrice = candle.low * (1 + pos.trailingStop / 100);
          if (!pos._trailPrice || newTrailPrice < pos._trailPrice) pos._trailPrice = newTrailPrice;
          if (candle.high >= pos._trailPrice) { closePrice = pos._trailPrice; reason = 'trailing_stop'; }
        }
      }

      // Check SL
      if (!closePrice && pos.stopLoss > 0) {
        if (pos.direction === 'long' && candle.low <= pos.stopLoss) { closePrice = pos.stopLoss; reason = 'sl'; }
        if (pos.direction === 'short' && candle.high >= pos.stopLoss) { closePrice = pos.stopLoss; reason = 'sl'; }
      }

      // Check TP
      if (!closePrice && pos.takeProfit > 0) {
        if (pos.direction === 'long' && candle.high >= pos.takeProfit) { closePrice = pos.takeProfit; reason = 'tp'; }
        if (pos.direction === 'short' && candle.low <= pos.takeProfit) { closePrice = pos.takeProfit; reason = 'tp'; }
      }

      if (closePrice) {
        const slipped = this._applySlippage(closePrice, pos.direction === 'long' ? 'sell' : 'buy');
        const trade = this._closePosition(pos, slipped, candle.time, reason);
        closed.push(trade);
        this.positions.splice(i, 1);
      }
    }
    return closed;
  }

  _closeTrade(pos, price, time, reason) {
    const pnl = this._calcPnL(pos, price);
    const exitFee = pos.size * price * this.takerFee;
    this.totalFees += exitFee;
    const netPnl = pnl - exitFee;
    const rMultiple = pos.stopLoss > 0 ?
      netPnl / (Math.abs(pos.entryPrice - pos.stopLoss) * pos.size) : 0;

    const trade = {
      tradeId: pos.tradeId,
      direction: pos.direction,
      entryTime: pos.entryTime,
      exitTime: time,
      entryPrice: pos.entryPrice,
      exitPrice: price,
      size: pos.size,
      leverage: pos.leverage,
      fees: pos.feesPaid + exitFee,
      pnl: netPnl,
      rMultiple: +rMultiple.toFixed(3),
      reason: reason
    };
    this.closedTrades.push(trade);
    return trade;
  }

  _closePosition(pos, price, time, reason) {
    const trade = this._closeTrade(pos, price, time, reason);
    // Return margin + pnl to balance
    this.balance += pos.margin + trade.pnl;
    return trade;
  }

  closePositionById(posId, price, time) {
    const idx = this.positions.findIndex(p => p.tradeId === posId);
    if (idx === -1) return null;
    const pos = this.positions[idx];
    const slipped = this._applySlippage(price, pos.direction === 'long' ? 'sell' : 'buy');
    const trade = this._closePosition(pos, slipped, time, 'manual');
    this.positions.splice(idx, 1);
    return trade;
  }

  _applySlippage(price, side) {
    if (side === 'buy') return price * (1 + this.slippage);
    return price * (1 - this.slippage);
  }

  // Execute pending orders against candle open price (next candle execution)
  executeOrders(candle) {
    const filled = [];
    for (let i = this.pendingOrders.length - 1; i >= 0; i--) {
      const order = this.pendingOrders[i];
      if (order.status !== 'pending') continue;

      let fillPrice = null;
      const openPrice = candle.open;

      if (order.type === 'market') {
        fillPrice = openPrice;
      } else if (order.type === 'limit') {
        if (order.side === 'buy' && openPrice <= order.price) fillPrice = Math.min(openPrice, order.price);
        else if (order.side === 'sell' && openPrice >= order.price) fillPrice = Math.max(openPrice, order.price);
      } else if (order.type === 'stop') {
        if (order.side === 'buy' && candle.high >= order.price) fillPrice = Math.max(openPrice, order.price);
        else if (order.side === 'sell' && candle.low <= order.price) fillPrice = Math.min(openPrice, order.price);
      }

      if (fillPrice !== null) {
        const slipped = this._applySlippage(fillPrice, order.side);
        let size = order.size;

        // Partial fill
        if (this.partialFillPct < 1.0) {
          size = size * this.partialFillPct;
          if (size <= 0) continue;
        }

        const pos = this._openPosition(order.side, slipped, size, candle.time, order);
        if (pos) {
          order.status = 'filled';
          order.filledAt = candle.time;
          order.filledPrice = slipped;
          filled.push({ order, position: pos });
        }
        this.pendingOrders.splice(i, 1);
      }
    }
    return filled;
  }

  _openPosition(side, price, size, time, order) {
    const direction = side === 'buy' ? 'long' : 'short';
    const notional = size * price;
    const entryFee = notional * this.takerFee;
    const margin = this.mode === 'futures' ? notional / this.leverage : notional;

    if (margin + entryFee > this.balance) return null; // insufficient margin

    this.balance -= (margin + entryFee);
    this.totalFees += entryFee;

    const slPct = order.stopLoss || (+document.getElementById('tSL').value);
    const tpPct = order.takeProfit || (+document.getElementById('tTP').value);
    const trailPct = order.trailingStop || (+document.getElementById('tTrail').value);

    let sl = 0, tp = 0;
    if (slPct > 0) {
      sl = direction === 'long' ? price * (1 - slPct/100) : price * (1 + slPct/100);
    }
    if (tpPct > 0) {
      tp = direction === 'long' ? price * (1 + tpPct/100) : price * (1 - tpPct/100);
    }

    const pos = {
      tradeId: ++this.tradeIdCounter,
      direction, entryPrice: price, size,
      leverage: this.mode === 'futures' ? this.leverage : 1,
      margin, stopLoss: sl, takeProfit: tp,
      trailingStop: trailPct,
      _trailPrice: null,
      entryTime: time, exitTime: null,
      realizedPnL: 0, feesPaid: entryFee,
      liquidationPrice: 0
    };
    pos.liquidationPrice = this._calcLiquidationPrice(pos);
    this.positions.push(pos);
    return pos;
  }

  recordEquity(price) {
    this.totalCandles++;
    if (this.positions.length > 0) this.exposedCandles++;
    const eq = this.getEquity(price);
    this.equityCurve.push(eq);
    this.balanceCurve.push(this.balance);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: ExecutionEngine â€” bridges orders & TradingEngine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class ExecutionEngine {
  constructor(tradingEngine) { this.te = tradingEngine; }

  processCandle(candle, callbacks) {
    // 1. Execute pending orders at candle open
    const fills = this.te.executeOrders(candle);
    for (const f of fills) {
      if (callbacks.onOrderFilled) callbacks.onOrderFilled(f);
    }

    // 2. Check liquidations
    const liqs = this.te.checkLiquidations(candle);
    for (const l of liqs) {
      if (callbacks.onLiquidation) callbacks.onLiquidation(l);
    }

    // 3. Check SL/TP/Trailing
    const stops = this.te.checkStopsTakeProfits(candle);
    for (const s of stops) {
      if (callbacks.onOrderFilled) callbacks.onOrderFilled({ order: null, position: null, trade: s });
    }

    // 4. Record equity
    this.te.recordEquity(candle.close);

    return { fills, liquidations: liqs, stops };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: StrategyEngine â€” sandboxed JS strategy execution
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class StrategyEngine {
  constructor() {
    this.strategy = null;
    this.enabled = false;
    this.lastError = null;
  }

  load(code) {
    this.lastError = null;
    try {
      // Sandbox: create function that returns strategy object
      // Block access to window, document, fetch, DOM
      const wrapper = new Function(
        'window', 'document', 'fetch', 'XMLHttpRequest', 'WebSocket',
        'globalThis', 'self', 'top', 'parent', 'frames',
        'localStorage', 'sessionStorage', 'indexedDB',
        'navigator', 'location', 'history', 'alert', 'confirm', 'prompt',
        'setTimeout', 'setInterval', 'requestAnimationFrame',
        'importScripts', 'eval',
        `"use strict";
        ${code}
        return { init: typeof init==='function'?init:undefined,
                 onCandle: typeof onCandle==='function'?onCandle:undefined,
                 onOrderFilled: typeof onOrderFilled==='function'?onOrderFilled:undefined,
                 onLiquidation: typeof onLiquidation==='function'?onLiquidation:undefined,
                 onFinish: typeof onFinish==='function'?onFinish:undefined };`
      );
      this.strategy = wrapper(
        undefined,undefined,undefined,undefined,undefined,
        undefined,undefined,undefined,undefined,undefined,
        undefined,undefined,undefined,
        undefined,undefined,undefined,undefined,undefined,undefined,
        undefined,undefined,undefined,undefined
      );
      return true;
    } catch(e) {
      this.lastError = e.message;
      return false;
    }
  }

  buildCtx(tradingEngine, candles, currentCandle) {
    const price = currentCandle.close;
    return {
      candle: currentCandle,
      candles: candles,
      positions: tradingEngine.positions.map(p => ({...p})),
      equity: tradingEngine.getEquity(price),
      balance: tradingEngine.balance,
      fees: tradingEngine.totalFees,
      orders: tradingEngine.pendingOrders.map(o => ({...o})),
      utils: { Math }
    };
  }

  callInit(ctx) { return this._safeCall('init', ctx); }

  callOnCandle(ctx) {
    const result = this._safeCall('onCandle', ctx);
    // Strategy can return array of order commands
    if (Array.isArray(result)) return result;
    return [];
  }

  callOnOrderFilled(ctx) { return this._safeCall('onOrderFilled', ctx); }
  callOnLiquidation(ctx) { return this._safeCall('onLiquidation', ctx); }
  callOnFinish(ctx) { return this._safeCall('onFinish', ctx); }

  _safeCall(method, ctx) {
    if (!this.strategy || !this.strategy[method]) return null;
    try {
      return this.strategy[method](ctx);
    } catch(e) {
      this.lastError = `[${method}] ${e.message}`;
      this._showError(this.lastError);
      return null;
    }
  }

  _showError(msg) {
    const el = document.getElementById('stratError');
    if (el) { el.textContent = msg; el.classList.add('show'); }
  }

  clearError() {
    const el = document.getElementById('stratError');
    if (el) { el.textContent = ''; el.classList.remove('show'); }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: PerformanceEngine â€” metrics calculation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PerformanceEngine {
  static calc(tradingEngine) {
    const te = tradingEngine;
    const trades = te.closedTrades;
    const eq = te.equityCurve;
    const m = {};

    m.balance = te.balance;
    m.equity = eq.length ? eq[eq.length-1] : te.balance;
    m.unrealizedPnL = eq.length ? m.equity - te.balance : 0;
    m.realizedPnL = trades.reduce((s,t) => s + t.pnl, 0);
    m.totalFees = te.totalFees;
    m.tradeCount = trades.length;

    // Win rate
    const wins = trades.filter(t => t.pnl > 0);
    const losses = trades.filter(t => t.pnl <= 0);
    m.winRate = trades.length ? (wins.length / trades.length * 100) : 0;

    // Profit factor
    const grossProfit = wins.reduce((s,t) => s + t.pnl, 0);
    const grossLoss = Math.abs(losses.reduce((s,t) => s + t.pnl, 0));
    m.profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;

    // Max drawdown from equity curve
    let peak = 0, maxDD = 0;
    for (const e of eq) {
      if (e > peak) peak = e;
      const dd = (peak - e) / peak;
      if (dd > maxDD) maxDD = dd;
    }
    m.maxDrawdown = maxDD * 100;

    // Sharpe ratio (annualized, assuming each candle = 1 period)
    if (eq.length > 1) {
      const returns = [];
      for (let i = 1; i < eq.length; i++) {
        returns.push((eq[i] - eq[i-1]) / eq[i-1]);
      }
      const avgRet = returns.reduce((s,r) => s+r, 0) / returns.length;
      const stdRet = Math.sqrt(returns.reduce((s,r) => s + (r-avgRet)**2, 0) / returns.length);
      m.sharpe = stdRet > 0 ? (avgRet / stdRet) * Math.sqrt(252) : 0;
    } else {
      m.sharpe = 0;
    }

    // Expectancy
    const avgWin = wins.length ? grossProfit / wins.length : 0;
    const avgLoss = losses.length ? grossLoss / losses.length : 0;
    const winP = trades.length ? wins.length / trades.length : 0;
    const lossP = 1 - winP;
    m.expectancy = (winP * avgWin) - (lossP * avgLoss);

    // Kelly %
    if (avgLoss > 0 && winP > 0) {
      const wlRatio = avgWin / avgLoss;
      m.kelly = ((winP * wlRatio - lossP) / wlRatio) * 100;
    } else {
      m.kelly = 0;
    }

    // Avg R multiple
    const rTrades = trades.filter(t => t.rMultiple !== 0);
    m.avgR = rTrades.length ? rTrades.reduce((s,t) => s + t.rMultiple, 0) / rTrades.length : 0;

    // Max consecutive losses
    let maxConsecLoss = 0, consecLoss = 0;
    for (const t of trades) {
      if (t.pnl <= 0) { consecLoss++; if (consecLoss > maxConsecLoss) maxConsecLoss = consecLoss; }
      else consecLoss = 0;
    }
    m.maxConsecLoss = maxConsecLoss;

    // Exposure time %
    m.exposureTime = te.totalCandles > 0 ? (te.exposedCandles / te.totalCandles * 100) : 0;

    return m;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: MonteCarloEngine â€” multi-seed simulation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class MonteCarloEngine {
  static run(config) {
    const { numRuns, candlesPerRun, marketParams, strategyCode, strategyObject, tradingSettings } = config;
    const results = [];

    for (let run = 0; run < numRuns; run++) {
      const seed = marketParams.seed + run;
      const params = { ...marketParams, seed };
      const me = new MarketEngine();
      me.init(params);

      const te = new TradingEngine();
      Object.assign(te, {
        mode: tradingSettings.mode,
        leverage: tradingSettings.leverage,
        makerFee: tradingSettings.makerFee,
        takerFee: tradingSettings.takerFee,
        slippage: tradingSettings.slippage,
        maintRate: tradingSettings.maintRate,
        partialFillPct: tradingSettings.partialFillPct,
        balance: tradingSettings.initialBalance,
        initialBalance: tradingSettings.initialBalance
      });

      const ee = new ExecutionEngine(te);
      let se = null;

      if (strategyObject || strategyCode) {
        se = new StrategyEngine();
        if (strategyObject) {
          se.strategy = strategyObject;
        } else {
          se.load(strategyCode);
        }
        if (se.strategy && se.strategy.init) {
          const initCtx = {
            candle: null, candles: [], positions: [], equity: te.balance,
            balance: te.balance, fees: 0, orders: [], utils: { Math }
          };
          se.callInit(initCtx);
        }
      }

      for (let i = 0; i < candlesPerRun; i++) {
        const candle = me.nextCandle();
        ee.processCandle(candle, {});

        if (se && se.strategy) {
          const ctx = se.buildCtx(te, me.candles, candle);
          const orders = se.callOnCandle(ctx);
          if (Array.isArray(orders)) {
            for (const cmd of orders) {
              const side = cmd.side || 'buy';
              const type = cmd.type || 'market';
              const size = cmd.size || te.getOrderSize(candle.close);
              const price = cmd.price || candle.close;
              if (cmd.close) {
                // Close position by id or direction
                if (cmd.positionId) {
                  te.closePositionById(cmd.positionId, candle.close, candle.time);
                } else {
                  const toClose = te.positions.filter(p => p.direction === (cmd.side === 'sell' ? 'long' : 'short'));
                  for (const p of toClose) te.closePositionById(p.tradeId, candle.close, candle.time);
                }
              } else {
                te.createOrder(type, side, price, size, {
                  stopLoss: cmd.stopLoss || 0,
                  takeProfit: cmd.takeProfit || 0,
                  trailingStop: cmd.trailingStop || 0,
                  time: candle.time
                });
              }
            }
          }
        }
      }

      // Close remaining positions at last price
      const lastPrice = me.candles[me.candles.length - 1].close;
      while (te.positions.length > 0) {
        te.closePositionById(te.positions[0].tradeId, lastPrice, me.candles[me.candles.length-1].time);
      }

      const perf = PerformanceEngine.calc(te);
      results.push({
        seed, perf,
        equityCurve: te.equityCurve,
        finalEquity: perf.equity,
        totalReturn: ((perf.equity - te.initialBalance) / te.initialBalance * 100),
        maxDD: perf.maxDrawdown,
        sharpe: perf.sharpe,
        trades: perf.tradeCount,
        winRate: perf.winRate,
        profitFactor: perf.profitFactor
      });
    }

    // Aggregate statistics
    const returns = results.map(r => r.totalReturn);
    const sharpes = results.map(r => r.sharpe);
    const dds = results.map(r => r.maxDD);

    const mean = arr => arr.reduce((s,v) => s+v, 0) / arr.length;
    const std = arr => { const m = mean(arr); return Math.sqrt(arr.reduce((s,v) => s+(v-m)**2, 0)/arr.length); };
    const median = arr => { const s = [...arr].sort((a,b) => a-b); const m = Math.floor(s.length/2); return s.length%2 ? s[m] : (s[m-1]+s[m])/2; };

    const summary = {
      meanReturn: mean(returns),
      medianReturn: median(returns),
      bestReturn: Math.max(...returns),
      worstReturn: Math.min(...returns),
      stdReturn: std(returns),
      meanSharpe: mean(sharpes),
      meanMaxDD: mean(dds),
      worstMaxDD: Math.max(...dds)
    };

    return { results, summary };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: Chart â€” extended with trade markers & equity
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Chart {
  constructor(cv, eqCv) {
    this.cv = cv; this.ctx = cv.getContext('2d');
    this.eqCv = eqCv; this.eqCtx = eqCv ? eqCv.getContext('2d') : null;
    this.candles=[]; this.segs=[];
    this.markers = []; // {idx, type:'entry_long'|'entry_short'|'exit'|'liquidation', price, label}
    this.hlines = [];  // {price, color, label, startIdx, endIdx}
    this.equityCurve = [];
    this.mcEquityCurves = []; // for Monte Carlo overlay
    this.vOff=0; this.zoom=1;
    this.drag=false; this.dx=0; this.dOff=0;
    this.follow=true;
    this._bind();
  }
  resize() {
    const p=this.cv.parentElement, r=window.devicePixelRatio||1;
    this.cv.width=p.clientWidth*r; this.cv.height=p.clientHeight*r;
    this.cv.style.width=p.clientWidth+'px'; this.cv.style.height=p.clientHeight+'px';
    this.ctx.scale(r,r);
    if (this.eqCv) {
      const ep = this.eqCv.parentElement;
      this.eqCv.width=ep.clientWidth*r; this.eqCv.height=ep.clientHeight*r;
      this.eqCv.style.width=ep.clientWidth+'px'; this.eqCv.style.height=ep.clientHeight+'px';
      this.eqCtx.scale(r,r);
    }
  }
  get visN() { return Math.max(10, Math.floor(120/this.zoom)); }
  push(c) {
    this.candles.push(c);
    const ls = this.segs[this.segs.length-1];
    if (!ls||ls.regime!==c.regime) {
      this.segs.push({regime:c.regime, start:this.candles.length-1, end:this.candles.length-1,
        color:RG[c.regime].color, name:RG[c.regime].name});
    } else ls.end=this.candles.length-1;
    if (this.follow) this.vOff=0;
    this.draw();
  }
  addMarker(type, price, idx) {
    if (typeof idx === 'undefined') idx = this.candles.length - 1;
    this.markers.push({ idx, type, price });
  }
  addHLine(price, color, label, startIdx, endIdx) {
    this.hlines.push({ price, color, label, startIdx: startIdx||0, endIdx: endIdx||99999999 });
  }
  removeHLine(label) {
    this.hlines = this.hlines.filter(h => h.label !== label);
  }
  draw() {
    const {cv,ctx,candles,segs}=this;
    const dpr=window.devicePixelRatio||1;
    const W=cv.width/dpr, H=cv.height/dpr;
    ctx.clearRect(0,0,W,H);
    if (candles.length<1) {
      ctx.fillStyle='#243040'; ctx.font='13px IBM Plex Mono';
      ctx.textAlign='center';
      ctx.fillText('â–¶ START â€” aloita live-data', W/2, H/2); return;
    }
    const pL=8,pR=68,pT=16,pB=30;
    const cW=W-pL-pR, cH=H-pT-pB;
    const n=this.visN, tot=candles.length;
    const ei=Math.max(n, tot-this.vOff);
    const si=Math.max(0,ei-n);
    const vis=candles.slice(si,ei);
    if(!vis.length) return;
    const minL=Math.min(...vis.map(c=>c.low));
    const maxH=Math.max(...vis.map(c=>c.high));
    const pr=(maxH-minL)||1, mg=pr*0.05;
    const p2y=p=>pT+(1-(p-minL+mg)/(pr+2*mg))*cH;
    const cw=Math.max(1,(cW/vis.length)-1);
    const cx=i=>pL+(i/vis.length)*cW+cw*0.1;

    // grid
    ctx.strokeStyle='#1c2830'; ctx.lineWidth=1; ctx.setLineDash([2,4]);
    for(let i=0;i<=5;i++){
      const y=pT+(i/5)*cH;
      ctx.beginPath(); ctx.moveTo(pL,y); ctx.lineTo(W-pR,y); ctx.stroke();
      const pr2=maxH+mg-(i/5)*(pr+2*mg);
      ctx.fillStyle='#4a6070'; ctx.font='9px IBM Plex Mono'; ctx.textAlign='left';
      ctx.fillText(pr2.toFixed(0),W-pR+4,y+3);
    }
    ctx.setLineDash([]);

    // regime bg
    segs.forEach(s=>{
      const si2=Math.max(0,s.start-si), ei2=Math.min(vis.length-1,s.end-si);
      if(ei2<0||si2>=vis.length) return;
      ctx.fillStyle=s.color+'09';
      ctx.fillRect(pL+(si2/vis.length)*cW,pT,(ei2-si2+1)/vis.length*cW,cH);
    });

    // horizontal lines (SL, TP, Liquidation)
    for (const hl of this.hlines) {
      if (hl.price < minL - mg || hl.price > maxH + mg) continue;
      const hlSi = Math.max(0, hl.startIdx - si);
      const hlEi = Math.min(vis.length - 1, hl.endIdx - si);
      if (hlEi < 0 || hlSi >= vis.length) continue;
      const y = p2y(hl.price);
      ctx.strokeStyle = hl.color; ctx.lineWidth = 1; ctx.setLineDash([4,3]);
      ctx.beginPath();
      ctx.moveTo(cx(hlSi), y);
      ctx.lineTo(cx(hlEi) + cw, y);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = hl.color; ctx.font = '8px IBM Plex Mono'; ctx.textAlign = 'left';
      ctx.fillText(hl.label + ' ' + hl.price.toFixed(0), cx(hlEi) + cw + 2, y - 2);
    }

    // candles
    vis.forEach((c,i)=>{
      const x=cx(i), bw=Math.max(1,cw*0.8);
      const bull=c.close>=c.open, col=bull?'#26de81':'#fc5c65';
      const by1=p2y(Math.max(c.open,c.close)), by2=p2y(Math.min(c.open,c.close));
      const bH=Math.max(1,by2-by1);
      ctx.strokeStyle=col; ctx.lineWidth=Math.max(1,bw*0.12);
      ctx.beginPath();
      ctx.moveTo(x+bw/2,p2y(c.high)); ctx.lineTo(x+bw/2,by1);
      ctx.moveTo(x+bw/2,by2);         ctx.lineTo(x+bw/2,p2y(c.low));
      ctx.stroke();
      ctx.fillStyle=col; ctx.fillRect(x,by1,bw,bH);
      if(bw>3){ctx.strokeStyle=col;ctx.lineWidth=0.5;ctx.strokeRect(x,by1,bw,bH);}
    });

    // trade markers
    for (const mk of this.markers) {
      const mi = mk.idx - si;
      if (mi < 0 || mi >= vis.length) continue;
      const x = cx(mi) + cw * 0.4;
      const y = p2y(mk.price);
      ctx.font = 'bold 12px IBM Plex Mono';
      ctx.textAlign = 'center';
      if (mk.type === 'entry_long') {
        ctx.fillStyle = '#26de81';
        ctx.fillText('â–²', x, y + 14);
      } else if (mk.type === 'entry_short') {
        ctx.fillStyle = '#fc5c65';
        ctx.fillText('â–¼', x, y - 6);
      } else if (mk.type === 'exit') {
        ctx.fillStyle = '#45aaf2';
        ctx.fillText('âœ•', x, y - 6);
      } else if (mk.type === 'liquidation') {
        ctx.fillStyle = '#a55eea';
        ctx.fillText('â˜ ', x, y - 6);
      }
    }

    // last price
    const lc=vis[vis.length-1].close, ly=p2y(lc);
    ctx.strokeStyle='#45aaf2'; ctx.lineWidth=1; ctx.setLineDash([3,4]);
    ctx.beginPath(); ctx.moveTo(pL,ly); ctx.lineTo(W-pR,ly); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='#45aaf2'; ctx.font='bold 10px IBM Plex Mono'; ctx.textAlign='left';
    ctx.fillText(lc.toFixed(2),W-pR+4,ly+3);

    // x labels
    const step=Math.max(1,Math.floor(vis.length/7));
    ctx.fillStyle='#4a6070'; ctx.font='9px IBM Plex Mono'; ctx.textAlign='center';
    vis.forEach((c,i)=>{
      if(i%step===0){const d=new Date(c.time);ctx.fillText(`${d.getHours()}:${String(d.getMinutes()).padStart(2,'0')}`,cx(i)+cw/2,H-pB+12);}
    });
    this._v=vis; this._si=si; this._cx=cx; this._cw=cw; this._p2y=p2y;
    this._cW=cW; this._pL=pL;

    // Draw equity chart
    this._drawEquity();
  }

  _drawEquity() {
    if (!this.eqCtx || this.equityCurve.length < 2) return;
    const ctx = this.eqCtx;
    const dpr = window.devicePixelRatio || 1;
    const W = this.eqCv.width / dpr, H = this.eqCv.height / dpr;
    ctx.clearRect(0, 0, W, H);

    const pL = 8, pR = 68, pT = 4, pB = 4;
    const cW = W - pL - pR, cH = H - pT - pB;

    // Label
    ctx.fillStyle = '#4a6070'; ctx.font = '9px IBM Plex Mono'; ctx.textAlign = 'left';
    ctx.fillText('EQUITY', pL, pT + 8);

    const drawCurve = (data, color, alpha) => {
      if (data.length < 2) return;
      const minV = Math.min(...data);
      const maxV = Math.max(...data);
      const range = (maxV - minV) || 1;
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      for (let i = 0; i < data.length; i++) {
        const x = pL + (i / (data.length - 1)) * cW;
        const y = pT + (1 - (data[i] - minV) / range) * cH;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    };

    // MC overlay curves
    for (const curve of this.mcEquityCurves) {
      drawCurve(curve, '#4a6070', 0.3);
    }

    // Main equity curve
    const eq = this.equityCurve;
    const initial = eq[0] || 0;
    const current = eq[eq.length - 1] || 0;
    const color = current >= initial ? '#26de81' : '#fc5c65';
    drawCurve(eq, color, 1);

    // Right side value
    ctx.fillStyle = color; ctx.font = 'bold 10px IBM Plex Mono'; ctx.textAlign = 'left';
    ctx.fillText(current.toFixed(0), W - pR + 4, H / 2 + 4);
  }

  _bind() {
    const cv=this.cv;
    cv.addEventListener('wheel',e=>{
      e.preventDefault();
      if(e.ctrlKey) this.zoom=Math.max(0.2,Math.min(8,this.zoom*(e.deltaY>0?1.15:0.87)));
      else {
        const s=Math.max(1,Math.floor(this.visN*0.1));
        this.vOff=Math.max(0,Math.min(this.candles.length-2,this.vOff+(e.deltaY>0?-s:s)));
        this.follow=this.vOff<=0;
      }
      this.draw();
    },{passive:false});
    cv.addEventListener('mousedown',e=>{this.drag=true;this.dx=e.clientX;this.dOff=this.vOff;});
    cv.addEventListener('mousemove',e=>{
      if(this.drag&&this._cW){
        const d=e.clientX-this.dx, pp=this._cW/this.visN;
        this.vOff=Math.max(0,Math.min(this.candles.length-2,this.dOff-Math.round(d/pp)));
        this.follow=this.vOff<=0; this.draw();
      }
      this._tt(e);
    });
    cv.addEventListener('mouseup',  ()=>this.drag=false);
    cv.addEventListener('mouseleave',()=>{this.drag=false;document.getElementById('tooltip').classList.remove('vis');});
  }
  _tt(e) {
    if(!this._v) return;
    const rect=this.cv.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const idx=Math.floor((mx-this._pL)/this._cW*this._v.length);
    const tt=document.getElementById('tooltip');
    if(idx<0||idx>=this._v.length){tt.classList.remove('vis');return;}
    const c=this._v[idx]; const R=RG[c.regime];
    tt.classList.add('vis');
    let tx=mx+14; if(tx+160>rect.width) tx=mx-168;
    tt.style.left=tx+'px'; tt.style.top=(e.clientY-rect.top-90)+'px';
    const d=new Date(c.time);
    document.getElementById('tta').textContent=`${d.getHours()}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
    document.getElementById('tto').textContent=c.open.toFixed(2);
    document.getElementById('tth').textContent=c.high.toFixed(2);
    document.getElementById('ttl').textContent=c.low.toFixed(2);
    document.getElementById('ttc').textContent=c.close.toFixed(2);
    document.getElementById('ttv').textContent=c.volume.toLocaleString('fi');
    document.getElementById('ttr').style.color=R.color;
    document.getElementById('ttr').textContent=R.name;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODULE: UIRenderer â€” updates trading panel UI elements
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class UIRenderer {
  static updatePositions(positions, currentPrice) {
    const list = document.getElementById('posList');
    const count = document.getElementById('posCount');
    count.textContent = `(${positions.length})`;
    if (!positions.length) { list.innerHTML = '<div style="color:var(--muted);font-size:10px;padding:4px">No open positions</div>'; return; }
    list.innerHTML = positions.map(p => {
      const pnl = p.direction === 'long' ? (currentPrice - p.entryPrice) * p.size : (p.entryPrice - currentPrice) * p.size;
      const pnlPct = (pnl / p.margin * 100).toFixed(1);
      const pnlClass = pnl >= 0 ? 'up' : 'down';
      return `<div class="pos-item">
        <div class="pos-head">
          <span class="${p.direction === 'long' ? 'up' : 'down'}" style="font-weight:700">${p.direction.toUpperCase()} ${p.leverage}Ã—</span>
          <span class="${pnlClass}" style="font-weight:600">${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)} (${pnlPct}%)</span>
          <button class="pos-close-btn" onclick="event.stopPropagation();closePos(${p.tradeId})">âœ•</button>
        </div>
        <div class="pos-detail">
          <span>Entry: ${p.entryPrice.toFixed(2)}</span>
          <span>Size: ${p.size.toFixed(4)}</span>
          <span>Margin: ${p.margin.toFixed(2)}</span>
          ${p.stopLoss > 0 ? `<span style="color:var(--red)">SL: ${p.stopLoss.toFixed(2)}</span>` : ''}
          ${p.takeProfit > 0 ? `<span style="color:var(--green)">TP: ${p.takeProfit.toFixed(2)}</span>` : ''}
          ${p.liquidationPrice > 0 ? `<span style="color:var(--purple)">Liq: ${p.liquidationPrice.toFixed(2)}</span>` : ''}
        </div>
      </div>`;
    }).join('');
  }

  static updateMetrics(metrics) {
    const s = (id, val, cls) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = val;
      if (cls) el.className = 'stat-value sm ' + cls;
    };
    s('pmBal', metrics.balance.toFixed(2), 'neu');
    s('pmEq', metrics.equity.toFixed(2), metrics.equity >= metrics.balance ? 'up' : 'down');
    s('pmUPnl', metrics.unrealizedPnL.toFixed(2), metrics.unrealizedPnL >= 0 ? 'up' : 'down');
    s('pmRPnl', metrics.realizedPnL.toFixed(2), metrics.realizedPnL >= 0 ? 'up' : 'down');
    s('pmWR', metrics.winRate.toFixed(1) + '%', metrics.winRate >= 50 ? 'up' : 'down');
    s('pmPF', metrics.profitFactor === Infinity ? 'âˆ' : metrics.profitFactor.toFixed(2), metrics.profitFactor >= 1 ? 'up' : 'down');
    s('pmSh', metrics.sharpe.toFixed(2), metrics.sharpe >= 0 ? 'up' : 'down');
    s('pmDD', metrics.maxDrawdown.toFixed(1) + '%', 'down');
    s('pmExp', metrics.expectancy.toFixed(2), metrics.expectancy >= 0 ? 'up' : 'down');
    s('pmKe', metrics.kelly.toFixed(1) + '%', metrics.kelly >= 0 ? 'up' : 'down');
    s('pmAvgR', metrics.avgR.toFixed(2), metrics.avgR >= 0 ? 'up' : 'down');
    s('pmMCL', metrics.maxConsecLoss, 'down');
    s('pmExpo', metrics.exposureTime.toFixed(1) + '%', 'neu');
    s('pmFees', metrics.totalFees.toFixed(2), 'down');
  }

  static updateTradeLog(trades) {
    const log = document.getElementById('tradeLog');
    const count = document.getElementById('tradeCount');
    count.textContent = `(${trades.length})`;
    // Show last 50 trades, newest first
    const recent = trades.slice(-50).reverse();
    log.innerHTML = recent.map(t => {
      const dirClass = t.direction === 'long' ? 'long' : 'short';
      const pnlClass = t.pnl >= 0 ? 'up' : 'down';
      return `<div class="trade-log-item">
        <span class="dir ${dirClass}">${t.direction === 'long' ? 'L' : 'S'}</span>
        <span>${t.entryPrice.toFixed(0)}â†’${t.exitPrice.toFixed(0)}</span>
        <span style="color:var(--muted);font-size:9px">${t.reason}</span>
        <span class="pnl ${pnlClass}">${t.pnl >= 0 ? '+' : ''}${t.pnl.toFixed(2)}</span>
      </div>`;
    }).join('');
  }

  static updateEquityTicker(equity) {
    const el = document.getElementById('tkEq');
    if (el) {
      el.textContent = equity.toFixed(0);
      el.style.color = equity >= (tradingEngine ? tradingEngine.initialBalance : 10000) ? 'var(--green)' : 'var(--red)';
    }
  }

  static showMCResults(data) {
    const el = document.getElementById('mcResults');
    const s = data.summary;
    let html = `<div style="margin-bottom:8px">
      <div class="panel-title" style="margin-bottom:6px">Summary (${data.results.length} runs)</div>
      <table class="mc-table">
        <tr><td>Mean Return</td><td class="${s.meanReturn>=0?'up':'down'}">${s.meanReturn.toFixed(2)}%</td></tr>
        <tr><td>Median Return</td><td class="${s.medianReturn>=0?'up':'down'}">${s.medianReturn.toFixed(2)}%</td></tr>
        <tr><td>Best</td><td class="up">${s.bestReturn.toFixed(2)}%</td></tr>
        <tr><td>Worst</td><td class="down">${s.worstReturn.toFixed(2)}%</td></tr>
        <tr><td>Std Dev</td><td class="neu">${s.stdReturn.toFixed(2)}%</td></tr>
        <tr><td>Mean Sharpe</td><td class="${s.meanSharpe>=0?'up':'down'}">${s.meanSharpe.toFixed(3)}</td></tr>
        <tr><td>Mean Max DD</td><td class="down">${s.meanMaxDD.toFixed(2)}%</td></tr>
        <tr><td>Worst Max DD</td><td class="down">${s.worstMaxDD.toFixed(2)}%</td></tr>
      </table>
    </div>`;

    html += `<div class="panel-title" style="margin-bottom:6px">Per-Seed Results</div>
    <table class="mc-table">
      <thead><tr><th>Seed</th><th>Return</th><th>Sharpe</th><th>MaxDD</th><th>Trades</th><th>WR</th></tr></thead>
      <tbody>`;
    for (const r of data.results) {
      html += `<tr>
        <td>${r.seed}</td>
        <td class="${r.totalReturn>=0?'up':'down'}">${r.totalReturn.toFixed(1)}%</td>
        <td>${r.sharpe.toFixed(2)}</td>
        <td class="down">${r.maxDD.toFixed(1)}%</td>
        <td>${r.trades}</td>
        <td>${r.winRate.toFixed(0)}%</td>
      </tr>`;
    }
    html += '</tbody></table>';
    el.innerHTML = html;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// APPLICATION STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let chart, gen, timer=null, speed=800;
let live=false, paused=false;
let candles=[], peak=0, maxDD=0, sp0=0;

// Engine instances
let marketEngine = new MarketEngine();
let tradingEngine = new TradingEngine();
let executionEngine = new ExecutionEngine(tradingEngine);
let strategyEngine = new StrategyEngine();

function gp() {
  return { sp:+document.getElementById('rS').value,
           bv:+document.getElementById('rV').value/100,
           bias:+document.getElementById('rB').value/100,
           sw:+document.getElementById('rSw').value,
           seed:+document.getElementById('rSd').value };
}

function getTradingSettings() {
  return {
    mode: document.getElementById('tMode').value,
    leverage: +document.getElementById('tLev').value,
    makerFee: +document.getElementById('tMakerFee').value / 100,
    takerFee: +document.getElementById('tTakerFee').value / 100,
    slippage: +document.getElementById('tSlippage').value / 100,
    maintRate: +document.getElementById('tMaintRate').value / 100,
    partialFillPct: +document.getElementById('tPartialFill').value / 100,
    initialBalance: +document.getElementById('tBalance').value
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onTradingModeChange() {
  const mode = document.getElementById('tMode').value;
  const levSel = document.getElementById('tLev');
  levSel.disabled = mode === 'spot';
  if (mode === 'spot') levSel.value = '1';
}

function manualBuy() {
  if (!live && !paused) return;
  const price = candles.length ? candles[candles.length-1].close : 0;
  if (!price) return;
  const size = tradingEngine.getOrderSize(price);
  tradingEngine.createOrder('market', 'buy', price, size, { time: candles[candles.length-1].time });
}

function manualSell() {
  if (!live && !paused) return;
  const price = candles.length ? candles[candles.length-1].close : 0;
  if (!price) return;
  const size = tradingEngine.getOrderSize(price);
  tradingEngine.createOrder('market', 'sell', price, size, { time: candles[candles.length-1].time });
}

function closePos(tradeId) {
  if (!candles.length) return;
  const c = candles[candles.length-1];
  const trade = tradingEngine.closePositionById(tradeId, c.close, c.time);
  if (trade) {
    chart.addMarker('exit', trade.exitPrice, chart.candles.length - 1);
    chart.draw();
    updateTradingUI(c.close);
  }
}

function loadStrategy() {
  const code = document.getElementById('tStratCode').value.trim();
  if (!code) return;
  strategyEngine.clearError();
  const ok = strategyEngine.load(code);
  if (!ok) {
    strategyEngine._showError('Load error: ' + strategyEngine.lastError);
  } else {
    document.getElementById('tStratEnabled').checked = true;
    strategyEngine.enabled = true;
  }
}

function loadBundledStrategy() {
  strategyEngine.clearError();
  const strat = {
    init: typeof window.init === 'function' ? window.init : undefined,
    onCandle: typeof window.onCandle === 'function' ? window.onCandle : undefined,
    onOrderFilled: typeof window.onOrderFilled === 'function' ? window.onOrderFilled : undefined,
    onLiquidation: typeof window.onLiquidation === 'function' ? window.onLiquidation : undefined,
    onFinish: typeof window.onFinish === 'function' ? window.onFinish : undefined
  };
  if (typeof strat.onCandle !== 'function') {
    strategyEngine._showError('Bundled strategy not found. Make sure `arm_strategy_v2.js` is next to this HTML file.');
    return;
  }
  strategyEngine.strategy = strat;
  strategyEngine.enabled = true;
  const en = document.getElementById('tStratEnabled');
  if (en) en.checked = true;

  // Best-effort: populate textarea for editing / MC runs.
  const ta = document.getElementById('tStratCode');
  if (ta && !ta.value.trim()) {
    fetch('./arm_strategy_v2.js')
      .then(r => r.ok ? r.text() : Promise.reject(new Error('HTTP ' + r.status)))
      .then(txt => { ta.value = txt; })
      .catch(() => {});
  }
}

function uploadStrategy(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    document.getElementById('tStratCode').value = e.target.result;
    loadStrategy();
  };
  reader.readAsText(file);
}

function startLive() {
  if (paused) {
    paused=false; live=true;
    timer=setInterval(tick,speed);
    ui('live'); return;
  }
  const p=gp();
  marketEngine.init(p);
  gen = marketEngine.gen;
  candles=[]; peak=p.sp; maxDD=0; sp0=p.sp;

  // Reset trading engine with UI settings
  tradingEngine.reset();
  tradingEngine.loadSettings();
  executionEngine = new ExecutionEngine(tradingEngine);

  // Reset chart
  chart.candles=[]; chart.segs=[]; chart.markers=[]; chart.hlines=[];
  chart.equityCurve=[]; chart.mcEquityCurves=[];
  chart.vOff=0; chart.follow=true; chart.draw();

  // Show equity area
  document.getElementById('eqArea').style.display = 'block';
  chart.resize();

  document.getElementById('stS').textContent=sp0.toFixed(0);
  document.getElementById('liveCount').textContent='0';

  // Init strategy if enabled
  if (document.getElementById('tStratEnabled').checked) {
    strategyEngine.enabled = true;
    const code = document.getElementById('tStratCode').value.trim();
    if (code && !strategyEngine.strategy) {
      loadStrategy();
    }
    if (strategyEngine.strategy && strategyEngine.strategy.init) {
      const ctx = strategyEngine.buildCtx(tradingEngine, [], { close: sp0, open: sp0, high: sp0, low: sp0, volume: 0, regime: 'bull', time: new Date().toISOString(), i: 0 });
      strategyEngine.callInit(ctx);
    }
  }

  live=true; paused=false;
  timer=setInterval(tick,speed);
  ui('live');
}

function pauseLive() {
  if(!live) return;
  clearInterval(timer); timer=null;
  live=false; paused=true;
  ui('paused');
}

function stopLive() {
  clearInterval(timer); timer=null;
  live=false; paused=false;

  // Call onFinish if strategy
  if (strategyEngine.enabled && strategyEngine.strategy && candles.length) {
    const ctx = strategyEngine.buildCtx(tradingEngine, candles, candles[candles.length-1]);
    strategyEngine.callOnFinish(ctx);
  }

  ui('stopped');
}

function resetAll() {
  stopLive();
  chart.candles=[]; chart.segs=[]; chart.markers=[]; chart.hlines=[];
  chart.equityCurve=[]; chart.mcEquityCurves=[]; chart.draw();
  candles=[];
  tradingEngine.reset();
  strategyEngine.strategy = null;
  strategyEngine.enabled = false;
  document.getElementById('tStratEnabled').checked = false;
  document.getElementById('eqArea').style.display = 'none';
  document.getElementById('liveCount').textContent='0';
  document.getElementById('expInfo').innerHTML='Paina <strong>â–¶ START</strong> aloittaaksesi live-datan tallennuksen.';
  document.getElementById('btnExport').disabled=true;
  document.getElementById('btnExportTrades').disabled=true;
  document.getElementById('tlBar').innerHTML='';
  document.getElementById('mcResults').innerHTML='';
  RK.forEach(k=>{
    document.getElementById('pct-'+k).textContent='â€”';
    document.getElementById('ri-'+k).classList.remove('active');
  });
  ['stN','stH','stL','stDD','stRt'].forEach(id=>document.getElementById(id).textContent='â€”');
  ['pmBal','pmEq','pmUPnl','pmRPnl','pmWR','pmPF','pmSh','pmDD','pmExp','pmKe','pmAvgR','pmMCL','pmExpo','pmFees'].forEach(id=>{
    const el=document.getElementById(id); if(el) el.textContent='â€”';
  });
  document.getElementById('posList').innerHTML='';
  document.getElementById('tradeLog').innerHTML='';
  document.getElementById('posCount').textContent='(0)';
  document.getElementById('tradeCount').textContent='(0)';
  document.getElementById('tkEq').textContent='â€”';
}

function ui(state) {
  const dot=document.getElementById('dot');
  const badge=document.getElementById('liveBadge');
  const bS=document.getElementById('btnStart');
  const bP=document.getElementById('btnPause');
  const bSt=document.getElementById('btnStop');
  dot.className='logo-dot';
  badge.className='live-badge';
  if(state==='live'){
    dot.classList.add('live');
    badge.classList.add('show','live'); badge.textContent='LIVE';
    bS.disabled=true; bP.disabled=false; bSt.disabled=false;
  } else if(state==='paused'){
    dot.classList.add('paused');
    badge.classList.add('show','paused'); badge.textContent='PAUSED';
    bS.textContent='â–¶ RESUME'; bS.disabled=false; bP.disabled=true; bSt.disabled=false;
  } else {
    bS.textContent='â–¶ START'; bS.disabled=false; bP.disabled=true; bSt.disabled=true;
  }
}

function setSpeed(ms) {
  speed=ms;
  document.querySelectorAll('.speed-btn').forEach(b=>b.classList.toggle('active',+b.dataset.ms===ms));
  if(live){clearInterval(timer);timer=setInterval(tick,speed);}
}

function updateTradingUI(price) {
  // Update position list
  UIRenderer.updatePositions(tradingEngine.positions, price);

  // Update horizontal lines on chart for open positions
  chart.hlines = [];
  for (const pos of tradingEngine.positions) {
    if (pos.stopLoss > 0) chart.addHLine(pos.stopLoss, '#fc5c65', 'SL', pos.tradeId > 0 ? 0 : 0);
    if (pos.takeProfit > 0) chart.addHLine(pos.takeProfit, '#26de81', 'TP');
    if (pos.liquidationPrice > 0 && tradingEngine.mode === 'futures') {
      chart.addHLine(pos.liquidationPrice, '#a55eea', 'LIQ');
    }
  }

  // Update metrics
  const metrics = PerformanceEngine.calc(tradingEngine);
  UIRenderer.updateMetrics(metrics);

  // Update trade log
  UIRenderer.updateTradeLog(tradingEngine.closedTrades);

  // Update equity in chart
  chart.equityCurve = tradingEngine.equityCurve;

  // Update equity ticker
  UIRenderer.updateEquityTicker(tradingEngine.getEquity(price));

  // Enable trade export
  if (tradingEngine.closedTrades.length > 0) {
    document.getElementById('btnExportTrades').disabled = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TICK â€” main simulation loop step
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function tick() {
  const c = marketEngine.nextCandle();
  candles.push(c);
  chart.push(c);

  // Execute trading engine
  const result = executionEngine.processCandle(c, {
    onOrderFilled: (fill) => {
      if (fill.position) {
        const dir = fill.order && fill.order.side === 'buy' ? 'entry_long' : 'entry_short';
        chart.addMarker(dir, fill.position.entryPrice, chart.candles.length - 1);
      }
      if (fill.trade) {
        chart.addMarker('exit', fill.trade.exitPrice, chart.candles.length - 1);
        if (strategyEngine.enabled && strategyEngine.strategy) {
          const ctx = strategyEngine.buildCtx(tradingEngine, candles, c);
          strategyEngine.callOnOrderFilled(ctx);
        }
      }
    },
    onLiquidation: (trade) => {
      chart.addMarker('liquidation', trade.exitPrice, chart.candles.length - 1);
      if (strategyEngine.enabled && strategyEngine.strategy) {
        const ctx = strategyEngine.buildCtx(tradingEngine, candles, c);
        strategyEngine.callOnLiquidation(ctx);
      }
    }
  });

  // Run strategy
  if (strategyEngine.enabled && strategyEngine.strategy) {
    try {
      const ctx = strategyEngine.buildCtx(tradingEngine, candles, c);
      const orders = strategyEngine.callOnCandle(ctx);
      if (Array.isArray(orders)) {
        for (const cmd of orders) {
          if (cmd.close) {
            if (cmd.positionId) {
              tradingEngine.closePositionById(cmd.positionId, c.close, c.time);
            } else {
              const dir = cmd.side === 'sell' ? 'long' : 'short';
              const toClose = tradingEngine.positions.filter(p => p.direction === dir);
              for (const p of toClose) {
                const trade = tradingEngine.closePositionById(p.tradeId, c.close, c.time);
                if (trade) chart.addMarker('exit', trade.exitPrice, chart.candles.length - 1);
              }
            }
          } else {
            const side = cmd.side || 'buy';
            const type = cmd.type || 'market';
            const size = cmd.size || tradingEngine.getOrderSize(c.close);
            const price = cmd.price || c.close;
            tradingEngine.createOrder(type, side, price, size, {
              stopLoss: cmd.stopLoss || 0,
              takeProfit: cmd.takeProfit || 0,
              trailingStop: cmd.trailingStop || 0,
              time: c.time
            });
          }
        }
      }
    } catch(e) {
      strategyEngine._showError('Runtime: ' + e.message);
    }
  }

  // Update trading UI
  updateTradingUI(c.close);

  // flash edge
  const fl=document.getElementById('ncf');
  fl.classList.remove('f'); void fl.offsetWidth; fl.classList.add('f');

  // counter
  const cnt=document.getElementById('liveCount');
  cnt.textContent=candles.length;
  cnt.classList.remove('pulse'); void cnt.offsetWidth; cnt.classList.add('pulse');

  // ticker
  const prev=candles.length>1?candles[candles.length-2].close:sp0;
  const chg=((c.close-prev)/prev*100);
  ft('tkP',c.close.toFixed(2),c.close>=prev);
  ft('tkC',(chg>=0?'+':'')+chg.toFixed(2)+'%',chg>=0);
  ft('tkH',Math.max(...candles.map(x=>x.high)).toFixed(2),true);
  ft('tkL',Math.min(...candles.map(x=>x.low)).toFixed(2),false);
  ft('tkV',c.volume.toLocaleString('fi'),true);
  const re=document.getElementById('tkR');
  re.textContent=RG[c.regime].name; re.style.color=RG[c.regime].color;

  // stats
  if(c.high>peak) peak=c.high;
  const dd=(peak-c.low)/peak;
  if(dd>maxDD) maxDD=dd;
  const ret=((c.close-sp0)/sp0*100).toFixed(1);
  document.getElementById('stN').textContent=c.close.toFixed(2);
  document.getElementById('stN').className='stat-value '+(c.close>=sp0?'up':'down');
  document.getElementById('stH').textContent=Math.max(...candles.map(x=>x.high)).toFixed(2);
  document.getElementById('stL').textContent=Math.min(...candles.map(x=>x.low)).toFixed(2);
  document.getElementById('stDD').textContent=(maxDD*100).toFixed(1)+'%';
  document.getElementById('stRt').textContent=ret+'%';
  document.getElementById('stRt').className='stat-value '+(+ret>=0?'up':'down');

  // regime pcts
  const tot=candles.length;
  RK.forEach(k=>{
    const cnt2=gen.counts[k]||0;
    document.getElementById('pct-'+k).textContent=cnt2>0?(cnt2/tot*100).toFixed(1)+'%':'â€”';
    document.getElementById('ri-'+k).classList.toggle('active',cnt2>0);
  });

  // timeline
  const bar=document.getElementById('tlBar');
  bar.innerHTML='';
  chart.segs.forEach(s=>{
    const pct=((s.end-s.start+1)/tot*100).toFixed(2);
    const d=document.createElement('div');
    d.className='tl-seg'; d.style.width=pct+'%'; d.style.background=s.color;
    d.title=`${s.name}: ${pct}%`; bar.appendChild(d);
  });

  // export
  document.getElementById('btnExport').disabled=false;
  document.getElementById('expInfo').innerHTML=`<strong>${candles.length}</strong> kynttilÃ¤Ã¤ tallennettu â€” session kÃ¤ynnissÃ¤`;
}

function ft(id,val,up) {
  const el=document.getElementById(id);
  el.textContent=val;
  el.classList.remove('fu','fd'); void el.offsetWidth;
  el.classList.add(up?'fu':'fd');
  setTimeout(()=>el.classList.remove('fu','fd'),500);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MONTE CARLO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function runMonteCarlo() {
  const btn = document.getElementById('btnMC');
  btn.disabled = true;
  btn.textContent = 'â³ RUNNING...';

  // Defer to allow UI update
  setTimeout(() => {
    try {
      const numRuns = +document.getElementById('mcRuns').value || 50;
      const candlesPerRun = +document.getElementById('mcCandles').value || 500;
      const stratEnabled = document.getElementById('tStratEnabled').checked;
      const stratCode = stratEnabled ? document.getElementById('tStratCode').value.trim() : null;
      const stratObj = stratEnabled ? (strategyEngine && strategyEngine.strategy ? strategyEngine.strategy : null) : null;

      const config = {
        numRuns, candlesPerRun,
        marketParams: gp(),
        strategyCode: stratCode,
        strategyObject: stratObj,
        tradingSettings: getTradingSettings()
      };

      const mcData = MonteCarloEngine.run(config);

      // Display results
      UIRenderer.showMCResults(mcData);

      // Overlay equity curves if checked
      if (document.getElementById('mcOverlay').checked) {
        chart.mcEquityCurves = mcData.results.map(r => r.equityCurve);
        chart.draw();
      }
    } catch(e) {
      document.getElementById('mcResults').innerHTML =
        `<div style="color:var(--red)">MC Error: ${e.message}</div>`;
    } finally {
      btn.disabled = false;
      btn.textContent = 'â–¶ RUN MONTE CARLO';
    }
  }, 50);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let fmt='xlsx';

function openModal() {
  if(!candles.length) return;
  const n=candles.length;
  const t0=new Date(candles[0].time).toLocaleTimeString('fi');
  const t1=new Date(candles[n-1].time).toLocaleTimeString('fi');
  document.getElementById('modalSub').textContent=`${n} kynttilÃ¤Ã¤ Â· ${t0} â€“ ${t1}`;
  document.getElementById('modal').classList.add('show');
}
function closeModal() { document.getElementById('modal').classList.remove('show'); }
function selFmt(f) {
  fmt=f;
  document.getElementById('optXlsx').classList.toggle('sel',f==='xlsx');
  document.getElementById('optJson').classList.toggle('sel',f==='json');
}
function doExport() { fmt==='json'?expJSON():expXLSX(); closeModal(); }

function expJSON() {
  const out = {
    meta:{generated:new Date().toISOString(),candles:candles.length,
      startPrice:sp0,endPrice:candles[candles.length-1].close,
      maxDrawdown:(maxDD*100).toFixed(2)+'%',
      totalReturn:(((candles[candles.length-1].close-sp0)/sp0)*100).toFixed(2)+'%',
      params:gp()},
    regimeCounts:gen.counts,
    data:candles,
    trades:tradingEngine.closedTrades,
    equityCurve:tradingEngine.equityCurve
  };
  dl('market_live_'+ts()+'.json', JSON.stringify(out,null,2), 'application/json');
}

function expXLSX() {
  if (typeof XLSX === 'undefined') {
    const info = document.getElementById('expInfo');
    if (info) info.innerHTML = 'XLSX export unavailable (missing `XLSX`). Use JSON export or run with internet access.';
    return;
  }
  const wb = XLSX.utils.book_new();
  const hdr = ['#','Aika','Open','High','Low','Close','Volume','Regime','Regime (FI)'];
  const rows = candles.map(c=>[c.i,c.time,c.open,c.high,c.low,c.close,c.volume,c.regime,RG[c.regime].name]);
  const ws1 = XLSX.utils.aoa_to_sheet([hdr,...rows]);
  ws1['!cols']=[{wch:6},{wch:26},{wch:12},{wch:12},{wch:12},{wch:12},{wch:14},{wch:12},{wch:16}];
  XLSX.utils.book_append_sheet(wb, ws1, 'OHLCV Data');

  const tot=candles.length;
  const regRows=RK.map(k=>{
    const cnt=gen.counts[k]||0;
    const sub=candles.filter(c=>c.regime===k);
    const avgC=sub.length?(sub.reduce((a,c)=>a+c.close,0)/sub.length).toFixed(2):'â€”';
    const avgV=sub.length?(sub.reduce((a,c)=>a+c.volume,0)/sub.length).toFixed(0):'â€”';
    return [RG[k].name, k, cnt, cnt>0?(cnt/tot*100).toFixed(2)+'%':'0%', avgC, avgV];
  });

  const ws2 = XLSX.utils.aoa_to_sheet([
    ['Markkinadata â€” Session Tilastot'],
    [],
    ['Generoitu',       new Date().toISOString()],
    ['KynttilÃ¶itÃ¤',    tot],
    ['Aloitushinta',   sp0],
    ['Loppuhinta',     candles[tot-1].close.toFixed(2)],
    ['Kokonaistuotto', (((candles[tot-1].close-sp0)/sp0)*100).toFixed(2)+'%'],
    ['Max Drawdown',   (maxDD*100).toFixed(2)+'%'],
    ['Session alku',   candles[0].time],
    ['Session loppu',  candles[tot-1].time],
    [],
    ['Regiimi','Koodi','KynttilÃ¤t','Osuus','Avg Close','Avg Volume'],
    ...regRows
  ]);
  ws2['!cols']=[{wch:20},{wch:12},{wch:12},{wch:10},{wch:14},{wch:14}];
  XLSX.utils.book_append_sheet(wb, ws2, 'Tilastot');

  XLSX.writeFile(wb,'market_live_'+ts()+'.xlsx');
}

function exportTradeCSV() {
  const trades = tradingEngine.closedTrades;
  if (!trades.length) return;
  const hdr = 'tradeId,direction,entryTime,exitTime,entryPrice,exitPrice,size,leverage,fees,pnl,rMultiple,reason';
  const rows = trades.map(t =>
    `${t.tradeId},${t.direction},${t.entryTime},${t.exitTime},${t.entryPrice.toFixed(2)},${t.exitPrice.toFixed(2)},${t.size.toFixed(6)},${t.leverage},${t.fees.toFixed(4)},${t.pnl.toFixed(4)},${t.rMultiple},${t.reason}`
  );
  const csv = [hdr, ...rows].join('\n');
  dl('trades_'+ts()+'.csv', csv, 'text/csv');
}

function dl(fn,data,type) {
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([data],{type}));
  a.download=fn; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
}

function ts() {
  const d=new Date();
  return `${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}_${String(d.getHours()).padStart(2,'0')}${String(d.getMinutes()).padStart(2,'0')}${String(d.getSeconds()).padStart(2,'0')}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.addEventListener('DOMContentLoaded',()=>{
  const cv=document.getElementById('cc');
  const eqCv=document.getElementById('eqc');
  chart=new Chart(cv, eqCv);
  chart.resize(); chart.draw();
  window.addEventListener('resize',()=>{chart.resize();chart.draw();});
  onTradingModeChange();

  // Keep toggle and engine state in sync
  const stratToggle = document.getElementById('tStratEnabled');
  if (stratToggle) {
    stratToggle.addEventListener('change', (e) => {
      strategyEngine.enabled = !!e.target.checked;
      if (!strategyEngine.enabled) strategyEngine.clearError();
    });
  }

  // Default: load bundled strategy file if available.
  loadBundledStrategy();
});
</script>
</body>
</html>
